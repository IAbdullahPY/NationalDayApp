<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Tweet Stack (Responsive Smooth Fade)</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
  html, body { height:100%; margin:0; background:#000; }
  .stage { position:relative; width:100vw; height:100vh; overflow:hidden; display:grid; place-items:center; }
  .bg { position:absolute; inset:0; width:100%; height:100%; object-fit:contain; background:#000; z-index:0; }

  .frame {
    position: absolute; 
    z-index: 1;
    left: 50%; 
    top: 50%; 
    transform: translate(-50%, -50%);
    display: flex; 
    align-items: center; 
    justify-content: center;
    width: 100vw;
    height: 100vh;
  }

  .stack {
    width: 85vw;
    max-width: 750px;
    display: flex;
    flex-direction: column;
    gap: 20px;
    margin-top: 15vh;
    position: relative;
  }

  .tweet {
    position: relative;
    background: url("assets/bubble.gif") center/cover no-repeat;
    color: #ffffff;
    border-radius: 18px;
    padding: 2vh 2vw;
    box-shadow: 0 10px 28px rgba(0,0,0,.28);
    min-height: 10vh;
    font-size: 2vh;
    max-width: 100%;
    opacity: 0; /* start hidden */
  }

  /* Enter fade-in */
  .tweet.enter {
    opacity: 0;
  }
  .tweet.enter-active {
    opacity: 1;
    transition: opacity 1.2s ease; /* smoother entrance */
  }

  /* Exit fade-out */
  .tweet.exit {
    opacity: 1;
  }
  .tweet.exit-active {
    opacity: 0;
    transition: opacity 0.8s ease; /* faster exit */
  }

  @media (min-aspect-ratio: 16/10) {
    .stack {
      width: 25vw;
      max-width: 380px;
    }
    .tweet {
      font-size: 1.2em;
      min-height: 80px;
      padding: 16px 20px;
    }
  }

  .name {
    position:absolute;
    top:8px;
    left:16px;
    right:16px;
    font-weight:700;
    font-size:14px;
    color:#fff;
  }

  .text {
    margin-top:26px;
    font-size:18px; 
    line-height:1.42; 
    font-weight:600;
    word-break:break-word;
  }

  @media (min-height: 1500px) and (max-width: 1200px) {
    .stack {
      width: 95%;
      max-width: 1100px;
      gap: 30px;
    }
    .tweet {
      font-size: 1.4em;
      min-height: 140px;
      padding: 24px 32px;
    }
  }
</style>
</head>
<body>
  <div class="stage">
    <img class="bg" src="assets/background.jpg" alt="bg" />
    <div class="frame">
      <div class="stack" id="stack"></div>
    </div>
  </div>

<script>
  let messages = [];
  let head = 0;

  function isArabic(s) {
    return /[\u0600-\u06FF]/.test(s || "");
  }

  async function fetchAll() {
    const res = await fetch('/api/messages');
    const data = await res.json();
    messages = data.map(x => ({
      name: x.name ?? "",
      text: x.message ?? ""
    }));
    if (!messages.length) {
      messages = [{ name: "", text: "Waiting for messagesâ€¦" }];
    }
  }

  function bubble(item, extraClass = "") {
    const el = document.createElement('div');
    el.className = `tweet ${extraClass}`;
    const dir = isArabic(item.text) ? 'rtl' : 'ltr';
    el.innerHTML = `
      <div class="name" style="direction:${dir}; text-align:${dir==='rtl'?'right':'left'};">
        ${item.name || ""}
      </div>
      <div class="text" style="direction:${dir}; text-align:${dir==='rtl'?'right':'left'};">
        ${item.text || ""}
      </div>
    `;
    return el;
  }

  function render() {
    const stack = document.getElementById('stack');
    const oldTweets = Array.from(stack.children);

    // Animate old tweets out
    oldTweets.forEach(el => {
      el.classList.add('exit');
      requestAnimationFrame(() => el.classList.add('exit-active'));
    });

    // Remove old after animation
    setTimeout(() => {
      oldTweets.forEach(el => el.remove());

      // Add new tweets
      const items = [];
      for (let i = 0; i < 4; i++) {
        const msg = messages[(head + i) % messages.length];
        const el = bubble(msg, 'enter');
        items.push(el);
        stack.appendChild(el);
      }

      // Trigger fade-in
      requestAnimationFrame(() => {
        items.forEach(el => el.classList.add('enter-active'));
      });
    }, 800); // match exit duration
  }

  function tick() {
    head = (head + 4) % messages.length;
    render();
  }

  async function start() {
    await fetchAll();
    if (messages.length > 4) {
      head = messages.length - 4;
    }
    render();

    setInterval(() => tick(), 10000);
    setInterval(async () => await fetchAll(), 10000);
  }

  start();
</script>
</body>
</html>